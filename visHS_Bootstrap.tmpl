/**
* Name: Visited Hotspot Tracker
* Author: Connor Deckers (cdeckers)
* Date: 24 November 2016
*/

var plugin_Hotspots = (plugin_Hotspots !== undefined ? plugin_Hotspots : (function( $, undefined ) {
  function plugin(args) {
    var pub = {}; //Public facing functions and variables.
    var priv = {}; //Helper container to hold known-private variables.

    var settings = {};
    var defaults = {
      id: '',
      font: {
        size: '12px',
        family: 'Calibri',
        decoration: 'none',
        style: 'normal',
        weight: 'normal',
        color: 'white',
        shadow: '',
      },
      position: 'topleft',
      margin: {
        x: 0,
        y: 0,
      },
      parent: "#panoDIV",
      visibility: true,
      HotspotImage: '',
      Resources: '',
      Styles: {},
      ShowVisitedPanos: true,
    }

    //plugin-specific global-access plugin ID
    priv.SceneID = priv.SceneID || '';

    //plugin-specific global-access to onscreen container
    priv.InfoBox = priv.InfoBox || null;

    //Container for infospots
    priv.Spots = priv.Spots || {};

    //List of seen hotspots for this pano
    priv.Spots.History = priv.Spots.History || {};

    priv.VisitedPanoramas = priv.VisitedPanoramas || [];

    //Add CSS Styles
    priv.CSS = priv.CSS || {};

    //Global non-specific settings
    priv.Settings = priv.Settings || {};

    //Global spotindex array
    priv.SpotIndex = priv.SpotIndex || {};
    priv.SpotStack = priv.SpotStack || {};
    priv.SpotStackHistory = priv.SpotStackHistory || {};

    //Resource location
    priv.Resources = priv.Resources || "";
    priv.HotspotImage = priv.HotspotImage || "";

    //XML Source
    priv.XML = priv.XML || {};







    settings = $.extend(true, {}, defaults, args);
    if(settings.id == '')
    {
      console.error("Invalid ID set.");
      return false;
    }

    /**
     * Identifies the version of the plugin
     * @type {Number}
     */
    pub.version = 0.04;

   /*******************************
    *       PUBLIC FUNCTIONS      *
    *******************************/
    priv.sorted = {};

    pub.getspots = function() {
      var items = krpano.get('hotspot').getArray();
      $.each(items, function(k,v) {
        if(v.tag == "point")
        {
          $.each(settings.Styles, function (name, styles)
          {
            if(styles.styles.indexOf(v.style) > -1)
            {
              priv.sorted[name] = priv.sorted[name] || [];

              priv.SpotIndex[priv.SceneID] = priv.SpotIndex[priv.SceneID] || {};
              priv.SpotStack[priv.SceneID] = priv.SpotStack[priv.SceneID] || {};
              priv.SpotStackHistory[priv.SceneID] = priv.SpotStackHistory[priv.SceneID] || {};

              priv.SpotIndex[priv.SceneID][name] = priv.SpotIndex[priv.SceneID][name] || 0;

              if(styles.display)
              {
                priv.SpotStack[priv.SceneID][name] = priv.SpotStack[priv.SceneID][name] || [];
                priv.SpotStackHistory[priv.SceneID][name] = priv.SpotStackHistory[priv.SceneID][name] || [];
                if(priv.SpotStack[priv.SceneID][name].indexOf(v.name)  == -1 && priv.SpotStackHistory[priv.SceneID][name].indexOf(v.name) == -1)
                {
                  priv.SpotStack[priv.SceneID][name].push(v.name);
                }
              }

              priv.sorted[name].push({
                'name': v.name,
                'tooltip': ktools.I18N.getInstance().getMessage(v.tooltip),
                'pano': getPanoramaName(v.onclick),
              });
              priv.sorted[name]['display'] = styles.display;
              priv.sorted[name]['isPano'] = styles.isPano;

              var originalActions = krpano.get('action['+v.onclick+'].content');
              krpano.set('action['+v.onclick+'].content', originalActions + ' jscall(plugin_Hotspots().get("'+settings.id+'").click("'+v.name+'", "'+v.style+'", "'+name+'"));');

              return false; //escapes the .each loop, saving time by ignoring unnecessary checks.
            }
          });
        }
      });
    }

  
    /**
     * Allows the user to toggle the visibility of the text, for hooking into hide/show control events.
     * If called without a state argument, it will return the items current visibility status.
     * @author cdeckers
     * @version 0.1
     * @date    2016-12-22
     * @param   {bool}   state The items visibility state (true; false;)
     * @return  {bool}         Returns true if the item is successfully toggled.
     */
    pub.visible = function(state)
    {
      if(state === 'undefined') return settings.visibility;
      if(priv.container === 'undefined') return null;
      $(priv.container).css("display", state?"block":"none");
      settings.visibility = state;
      return true;
    }

    pub.dump = function()
    {
      console.log("Private data");
      console.log(priv);
      console.log("Public data");
      console.log(pub);
    }

    pub.click = function(name, style, category)
    {
      console.log("name: " + name + "; style: " + style + "; category: " + category);
    }

    /*******************************
     *      PRIVATE FUNCTIONS      *
     *******************************/

    //Draws container onto the screen, ready for content to be added
    function drawContainer()
    {
      if($('#'+settings.id).length === 0)
      {
        //Create the square
        var textElem = document.createElement('div');
        textElem.id = settings.id;

        //Add the container of the square to the container of the tour
        $(settings.parent).prepend(textElem);

        $(textElem).css({
            'position': 'absolute',
            'z-index': '3018',
            'overflow': 'visible',
            'opacity': '1',
            'text-size-adjust': 'none',
            'pointer-events': 'none',
            'background': 'none',
            'cursor': 'default',
          });

        var cssPosition = {};
        var size = 2;
        //Calculate the position
        switch (settings.position) {
          case 'topleft':
            cssPosition = { 'top': 0, 'left':0, 'margin-left': settings.margin.x, 'margin-top': settings.margin.y};
            break;

          case 'top':
            cssPosition = { 'top': 0, 'left': '50%', 'margin-left': (size/2)+'px', 'margin-top': settings.margin.y };
            break;

          case 'topright':
            cssPosition = { 'top': 0, 'right': 0, 'margin-top': settings.margin.y, 'margin-right': settings.margin.x };
            break;

          case 'right':
            cssPosition = { 'top': '50%', 'margin-top':(size/2)+'px', 'right':0, 'margin-right': settings.margin.x };
            break;

          case 'bottomright':
            cssPosition = { 'bottom': 0, 'right': 0, 'margin-right': settings.margin.x, 'margin-bottom': settings.margin.y };
            break;

          case 'bottom':
            cssPosition = { 'bottom': 0, 'left': '50%', 'margin-left': (size/2)+'px', 'margin-bottom': settings.margin.y }
            break;

          case 'bottomleft':
            cssPosition = { 'bottom' : 0, 'left' : 0,  'margin-bottom': settings.margin.y, 'margin-left': settings.margin.x };
            break;

          case 'left':
            cssPosition = {'left': 0, 'top': '50%', 'margin-top':(size/2)+'px', 'margin-left': settings.margin.x }
            break;

          case 'center':
            cssPosition = {'top': '50%', 'margin-top':(size/2)+'px', 'left': '50%', 'margin-left': (size/2)+'px'}
            break;
        }

        //Apply the position
        $(textElem).css(cssPosition);

        createStylesheet();

        return $(textElem);
      }
      return $('#'+settings.id);
    };

    function insertContent(container, info)
    {
      $(container).html('<p class="'+settings.id+'text">'+info+'</p>');
    }

    function getPanoramaName(actionname)
    {
      if(settings.ShowVisitedPanos)
      {
        var regex = /mainloadscene\(([^\)]+)/ig;
        var text = krpano.get('action['+actionname+'].content');
        if(text.indexOf("mainloadscene(") > -1)
        {
          var r = regex.exec(text);
          return r[1];
        }
      }
      return '';
    }

    /* Style tag generator */
    /* Can possibly be refactored into seperate script? */

    function createStylesheet()
    {
      addStyle("."+settings.id+"text", {
        "font-family":      settings.font.family,
        "font-weight":      settings.font.weight,
        "font-style":       settings.font.style,
        "text-decoration":  settings.font.decoration,
        "font-size":        settings.font.size + 'px',
        "color":            settings.font.color,
        "text-shadow":      settings.font.shadow,
      });
      generateCSS();
    }

    function addStyle(identifier, rule)
    {
      if(priv.CSS[identifier] == null) { priv.CSS[identifier] = {}; }
      $.extend(priv.CSS[identifier], rule);
    }

    function generateCSS()
    {
      var rules = "";
      $.each(priv.CSS, function(id, props)
      {
        rules += id + " {\n";
        $.each(props, function(property, rule) {
          rules += "\t"+property+":"+rule+";\n";
        });
        rules += "}\n\n";
      });

      $("head").append("<style>"+rules+"</style>");
    }

    return pub;
  }

  var items = {};
  function manager() {
    var pub = {};

    pub.register = function(id, props)
    {
      if(items.hasOwnProperty(id)) { console.error("Can't reregister item."); return items[id]; }
      else {
        if(props == undefined) { props = {}; }
        if(!props.hasOwnProperty('id')) { props = $.extend(true, props, {'id':id}); }
        var p = new plugin(props);
        items[id] = p; return p;
      }
    }

    pub.get = function(id)
    {
      if(items.hasOwnProperty(id)) { return items[id]; }
      else { console.error("Item with ID `" + id + "` doesn't exist. Register your item before you use .get()"); return false; }
    }

    pub.delete = function(id)
    {
      if(items.hasOwnProperty(id)) { delete items[id]; return items.hasOwnProperty(id); }
    }

    pub.dump = function()
    {
      console.log(items);
    }

    return pub;
  }
  return manager;
}(jQuery)))
